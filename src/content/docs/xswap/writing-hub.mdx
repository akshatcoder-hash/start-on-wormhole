---
title: "Implementing the Hub Model"
description: "Writing the contract to implement the Spoke model"
---


Hub is the place where assets are deposited, borrowed, and repaid. 

ğŸ› ï¸ **Step 1- Create Your Contract File:** ğŸ› ï¸

First things first! Create a new file named `Hub.sol` in your `src/` directory. This is where all the action happens!

**Step 2**: Kick things off by adding the license and the libraries you'll need. Paste the following code:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
import "wormhole-solidity-sdk/WormholeRelayerSDK.sol";
```

Remember our [Cross Chain Mailbox](https://startonwormhole.vercel.app/automatic-relayers/intro/) tutorial? Yep, we're using `wormhole-solidity-sdk` again for those awesome cross-chain features! ğŸŒ‰


**Step 3- Declare the Hub Contract: ğŸ¨** Time to declare our Hub contract! ğŸ‰ Add this code snippet:

```solidity
contract Hub is TokenSender, TokenReceiver {
   uint256 constant GAS_LIMIT = 250_000;
   enum Action {DEPOSIT, WITHDRAW, BORROW, REPAY}
```

Here, our `Hub` contract inherits from `TokenSender` and `TokenReceiver`. This aligns perfectly with the article's point about the hub being the central point for all token transactions. ğŸ”„

**Step 4 - Map Out Deposits and Borrows: ğŸ—ºï¸** 
Let's create some mappings to keep tabs on user deposits and borrows. ğŸ—ºï¸

```solidity
   mapping(address => mapping(address => uint256)) public vaultDeposits;
   mapping(address => mapping(address => uint256)) public vaultBorrows;
```

This is like the hub's own little ledger, keeping track of all the assets. ğŸ“š


**Step 5 - Initialize the Contract: ğŸ—ï¸** 
Now, let's set up the constructor to initialize our contract. ğŸ› ï¸

```solidity
   constructor(address _wormholeRelayer, address _tokenBridge, address _wormhole)
   TokenBase(_wormholeRelayer, _tokenBridge, _wormhole)
   {}
```

**Step 6- Quoting Function: ğŸ“Š** 
Add a function that estimates the cost of returning assets to a spoke. This is like the hub's own calculator! ğŸ§®.

```solidity
function quoteReturnDelivery(uint16 spokeChain) public view returns (uint256 cost) 
{
uint256 deliveryCost;

(deliveryCost,) = wormholeRelayer.quoteEVMDeliveryPrice(spokeChain, 0, GAS_LIMIT);
cost = deliveryCost + wormhole.messageFee();
}
```

**Step 7- The Heart of the Hub: ğŸ›ï¸** 
This function is the control center of the Hub. It's a bit long, but it's where the magic happens! ğŸŒŸ

```solidity
function receivePayloadAndTokens(
    bytes memory payload,
    TokenReceived[] memory receivedTokens,
    bytes32 sourceAddress,
    uint16 sourceChain,
    bytes32 deliveryHash
) 
internal override onlyWormholeRelayer isRegisteredSender(sourceChain, sourceAddress) replayProtect(deliveryHash) 
{
    if (receivedTokens.length == 0) {
        (Action action, address user, address tokenHomeAddress, uint256 amount) = abi.decode(payload, (Action, address, address, uint256));
        address tokenAddressOnThisChain = getTokenAddressOnThisChain(sourceChain, toWormholeFormat(tokenHomeAddress));

        if (action == Action.BORROW || action == Action.WITHDRAW) {
            if (updateHubState(action, user, tokenAddressOnThisChain, amount)) {
                sendTokenToUser(user, sourceChain, sourceAddress, tokenAddressOnThisChain, amount);
            }
        }
    } else if (receivedTokens.length == 1) {
        TokenReceived memory receivedToken = receivedTokens[0];
        (Action action, address user) = abi.decode(payload, (Action, address));

        if (action == Action.DEPOSIT || action == Action.REPAY) {
            updateHubState(action, user, receivedToken.tokenAddress, receivedToken.amount);
        }
    }
}

```

This function is like the Swiss Army knife of our Hub contract. It handles deposits, withdrawals, borrows, and repayments. It's the real MVP, aligning with everything the article talks about. ğŸ†


**Step 8- Update the Hub State: ğŸ”„** 
Now, let's add a function that updates the state of the Hub based on user actions. ğŸ”„

```solidity
function updateHubState(Action action, address user, address wrappedTokenAddress, uint256 amount) 
internal returns (bool success) 
{
    uint256 currentHubBalance = IERC20(wrappedTokenAddress).balanceOf(address(this));

    if (action == Action.DEPOSIT) {
        vaultDeposits[user][wrappedTokenAddress] += amount;

    } else if (action == Action.WITHDRAW) {
        if (vaultDeposits[user][wrappedTokenAddress] < amount) return false;
        if (currentHubBalance < amount) return false;
        vaultDeposits[user][wrappedTokenAddress] -= amount;

    } else if (action == Action.BORROW) {
        if (currentHubBalance < amount) return false;
        vaultBorrows[user][wrappedTokenAddress] += amount;

    } else if (action == Action.REPAY) {
        if (vaultBorrows[user][wrappedTokenAddress] < amount) {
            vaultDeposits[user][wrappedTokenAddress] += amount - vaultBorrows[user][wrappedTokenAddress];
            vaultBorrows[user][wrappedTokenAddress] = 0;
        } else {
            vaultBorrows[user][wrappedTokenAddress] -= amount;
        }
    }

    return true;
}
```

This function is like the hub's personal assistant, updating records and making sure everything is in tip-top shape! ğŸ“‹



**Step 9- Close the Contract ğŸ‰** You've made it to the end! Don't forget to close the contract with a `}`. ğŸ‰

